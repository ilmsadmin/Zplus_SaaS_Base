-- Migration: 013 Create File Management Tables
-- Description: Create comprehensive file management system with S3 support
-- Created: 2025-08-08

-- Enable UUID extension if not exists
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- File storage configuration table
CREATE TABLE file_storage_configs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id VARCHAR(50) REFERENCES tenants(id) ON DELETE CASCADE,
    storage_type VARCHAR(50) NOT NULL DEFAULT 'local', -- local, s3, minio, azure
    config JSONB NOT NULL DEFAULT '{}',
    is_active BOOLEAN DEFAULT true,
    max_file_size BIGINT DEFAULT 104857600, -- 100MB
    allowed_mime_types TEXT[] DEFAULT ARRAY['image/*', 'application/pdf', 'text/*'],
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(tenant_id, storage_type)
);

-- Files table (enhanced)
CREATE TABLE IF NOT EXISTS files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id VARCHAR(50) REFERENCES tenants(id) ON DELETE CASCADE,
    user_id UUID NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    original_name VARCHAR(255) NOT NULL,
    file_path TEXT NOT NULL,
    storage_type VARCHAR(50) DEFAULT 'local',
    mime_type VARCHAR(255) NOT NULL,
    size BIGINT NOT NULL,
    url TEXT,
    category VARCHAR(100) DEFAULT 'general', -- avatar, document, image, video, etc.
    tags TEXT[] DEFAULT ARRAY[]::TEXT[],
    is_public BOOLEAN DEFAULT false,
    is_processed BOOLEAN DEFAULT false, -- for image processing
    processing_status VARCHAR(50) DEFAULT 'pending', -- pending, processing, completed, failed
    checksum VARCHAR(64), -- SHA256 hash
    virus_scan_status VARCHAR(50) DEFAULT 'pending', -- pending, scanning, clean, infected, error
    virus_scan_result JSONB DEFAULT '{}',
    expiry_date TIMESTAMP,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP
);

-- File versions table (for version control)
CREATE TABLE file_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    file_id UUID REFERENCES files(id) ON DELETE CASCADE,
    version_number INTEGER NOT NULL DEFAULT 1,
    file_path TEXT NOT NULL,
    size BIGINT NOT NULL,
    checksum VARCHAR(64),
    metadata JSONB DEFAULT '{}',
    created_by UUID NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- File shares table (for file sharing permissions)
CREATE TABLE file_shares (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    file_id UUID REFERENCES files(id) ON DELETE CASCADE,
    shared_by UUID NOT NULL,
    shared_with UUID, -- NULL for public shares
    share_type VARCHAR(50) DEFAULT 'read', -- read, write, download
    access_token VARCHAR(255) UNIQUE,
    password_hash VARCHAR(255), -- for password-protected shares
    max_downloads INTEGER DEFAULT -1, -- -1 for unlimited
    download_count INTEGER DEFAULT 0,
    expires_at TIMESTAMP,
    is_active BOOLEAN DEFAULT true,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- File upload sessions table (for progress tracking)
CREATE TABLE file_upload_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_token VARCHAR(255) UNIQUE NOT NULL,
    tenant_id VARCHAR(50) REFERENCES tenants(id) ON DELETE CASCADE,
    user_id UUID NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_size BIGINT NOT NULL,
    chunk_size INTEGER DEFAULT 1048576, -- 1MB chunks
    total_chunks INTEGER NOT NULL,
    uploaded_chunks INTEGER DEFAULT 0,
    upload_path TEXT,
    status VARCHAR(50) DEFAULT 'pending', -- pending, uploading, completed, failed, cancelled
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP DEFAULT (CURRENT_TIMESTAMP + INTERVAL '24 hours')
);

-- File processing jobs table (for async image processing)
CREATE TABLE file_processing_jobs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    file_id UUID REFERENCES files(id) ON DELETE CASCADE,
    job_type VARCHAR(50) NOT NULL, -- resize, crop, compress, thumbnail, virus_scan
    job_params JSONB NOT NULL DEFAULT '{}',
    status VARCHAR(50) DEFAULT 'pending', -- pending, processing, completed, failed
    progress INTEGER DEFAULT 0, -- 0-100
    result JSONB DEFAULT '{}',
    error_message TEXT,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- File access logs table (for auditing)
CREATE TABLE file_access_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    file_id UUID REFERENCES files(id) ON DELETE CASCADE,
    user_id UUID,
    action VARCHAR(50) NOT NULL, -- upload, download, view, share, delete
    ip_address INET,
    user_agent TEXT,
    share_token VARCHAR(255), -- if accessed via share
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes for performance
CREATE INDEX idx_files_tenant_id ON files(tenant_id);
CREATE INDEX idx_files_user_id ON files(user_id);
CREATE INDEX idx_files_category ON files(category);
CREATE INDEX idx_files_mime_type ON files(mime_type);
CREATE INDEX idx_files_created_at ON files(created_at);
CREATE INDEX idx_files_size ON files(size);
CREATE INDEX idx_files_is_public ON files(is_public);
CREATE INDEX idx_files_virus_scan_status ON files(virus_scan_status);
CREATE INDEX idx_files_processing_status ON files(processing_status);
CREATE INDEX idx_files_deleted_at ON files(deleted_at) WHERE deleted_at IS NULL;

CREATE INDEX idx_file_versions_file_id ON file_versions(file_id);
CREATE INDEX idx_file_versions_version_number ON file_versions(version_number);

CREATE INDEX idx_file_shares_file_id ON file_shares(file_id);
CREATE INDEX idx_file_shares_shared_with ON file_shares(shared_with);
CREATE INDEX idx_file_shares_access_token ON file_shares(access_token);
CREATE INDEX idx_file_shares_expires_at ON file_shares(expires_at);
CREATE INDEX idx_file_shares_is_active ON file_shares(is_active);

CREATE INDEX idx_file_upload_sessions_token ON file_upload_sessions(session_token);
CREATE INDEX idx_file_upload_sessions_user_id ON file_upload_sessions(user_id);
CREATE INDEX idx_file_upload_sessions_status ON file_upload_sessions(status);
CREATE INDEX idx_file_upload_sessions_expires_at ON file_upload_sessions(expires_at);

CREATE INDEX idx_file_processing_jobs_file_id ON file_processing_jobs(file_id);
CREATE INDEX idx_file_processing_jobs_status ON file_processing_jobs(status);
CREATE INDEX idx_file_processing_jobs_job_type ON file_processing_jobs(job_type);

CREATE INDEX idx_file_access_logs_file_id ON file_access_logs(file_id);
CREATE INDEX idx_file_access_logs_user_id ON file_access_logs(user_id);
CREATE INDEX idx_file_access_logs_action ON file_access_logs(action);
CREATE INDEX idx_file_access_logs_created_at ON file_access_logs(created_at);

-- Create triggers for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_file_storage_configs_updated_at BEFORE UPDATE ON file_storage_configs FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_files_updated_at BEFORE UPDATE ON files FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_file_shares_updated_at BEFORE UPDATE ON file_shares FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_file_upload_sessions_updated_at BEFORE UPDATE ON file_upload_sessions FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_file_processing_jobs_updated_at BEFORE UPDATE ON file_processing_jobs FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Add default storage config for each tenant
INSERT INTO file_storage_configs (tenant_id, storage_type, config, max_file_size, allowed_mime_types)
SELECT 
    id as tenant_id,
    'local' as storage_type,
    '{"base_path": "/uploads", "public_url": "http://localhost:8080/uploads"}' as config,
    104857600 as max_file_size, -- 100MB
    ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'application/pdf', 'text/plain', 'text/csv', 'application/json'] as allowed_mime_types
FROM tenants;

-- Function to auto-create storage config for new tenants
CREATE OR REPLACE FUNCTION create_default_file_storage_config()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO file_storage_configs (tenant_id, storage_type, config, max_file_size, allowed_mime_types)
    VALUES (
        NEW.id,
        'local',
        '{"base_path": "/uploads", "public_url": "http://localhost:8080/uploads"}',
        104857600, -- 100MB
        ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'application/pdf', 'text/plain', 'text/csv', 'application/json']
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_create_default_file_storage_config
    AFTER INSERT ON tenants
    FOR EACH ROW
    EXECUTE FUNCTION create_default_file_storage_config();

-- Add comments for documentation
COMMENT ON TABLE file_storage_configs IS 'Configuration for different storage backends per tenant';
COMMENT ON TABLE files IS 'Main files table with multi-tenant support and advanced features';
COMMENT ON TABLE file_versions IS 'File version history for change tracking';
COMMENT ON TABLE file_shares IS 'File sharing permissions and access control';
COMMENT ON TABLE file_upload_sessions IS 'Chunked upload session tracking';
COMMENT ON TABLE file_processing_jobs IS 'Async job queue for file processing';
COMMENT ON TABLE file_access_logs IS 'Audit trail for file access and operations';
